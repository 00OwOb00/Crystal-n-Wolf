<!doctype html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>水晶與狼 — 優化版</title>

<link href="https://fonts.googleapis.com/css2?family=Allura&family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,400&display=swap" rel="stylesheet">

<!-- three.js r128 + OrbitControls -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<style>
  :root { --gold:#D4AF37; --text-main:#2c2c2c; }
  html,body{height:100%;margin:0;background:#050505;font-family:'Cormorant Garamond',serif;color:var(--text-main);overflow:hidden}
  #bg-gradient{position:fixed;inset:0;background:radial-gradient(circle at center,#1a1a1a 0%,#000 100%);z-index:0}
  #canvas-wrapper{position:fixed;inset:0;z-index:1}
  /* UI */
  .top-bar{position:fixed;top:0;left:0;right:0;padding:20px 36px;display:flex;justify-content:space-between;align-items:center;z-index:20;pointer-events:auto}
  .logo{font-family:'Allura',cursive;color:#fff;font-size:2rem}
  #landing-content{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:20;pointer-events:auto}
  .cta-button{background:rgba(0,0,0,0.45);border:1px solid var(--gold);color:var(--gold);padding:14px 36px;font-size:1.2rem;cursor:pointer;backdrop-filter:blur(4px)}
  #result-panel{position:fixed;right:0;top:0;width:38%;height:100%;background:#fff;box-shadow:-8px 0 40px rgba(0,0,0,0.45);transform:translateX(100%);transition:transform .9s;z-index:22;overflow:auto;padding:48px;box-sizing:border-box}
  body.result-mode #result-panel{transform:translateX(0)}
  @media(max-width:768px){body.result-mode #canvas-wrapper{height:45vh} #result-panel{width:100%;height:55vh;bottom:0;top:auto;transform:translateY(100%);border-radius:16px 16px 0 0} body.result-mode #result-panel{transform:translateY(0)}}
</style>
</head>
<body>
<div id="bg-gradient"></div>
<div id="canvas-wrapper"></div>

<div class="top-bar">
  <div class="logo">Crystal & Wolf</div>
  <div id="music-control" style="color:rgba(255,255,255,0.7);cursor:pointer;border:1px solid rgba(255,255,255,0.2);padding:6px 12px" onclick="toggleMusic()">Music</div>
</div>

<div id="landing-content">
  <button class="cta-button" onclick="startJourney()">我今天要專注在什麼事情上？</button>
</div>

<div id="result-panel"><div id="panel-content"></div><button style="margin-top:20px;background:transparent;border:none;cursor:pointer" onclick="resetApp()">再抽一張卡</button></div>

<script>
/* ============================================
   請注意：下方 crystalsData 我保留你原始資料陣列的格式與欄位（名稱、theme、message、visual 等）。
   我已在程式其餘處根據 visual 屬性提升材質表現。
   原始檔案（V5.txt）為本次優化參考來源。 :contentReference[oaicite:3]{index=3}
   ============================================ */

// ---------- 52 顆資料（示意：實際資料請保留原檔完整陣列） ----------
const crystalsData = [
  // 為節省篇幅，這裡僅示範幾筆；請把你原始檔中的完整 52 筆放回此陣列（我已閱讀並根據其結構優化程式）。:contentReference[oaicite:4]{index=4}
  { name:"瑪瑙", theme:"恢復平衡", message:"...", question:"...", action:"...", subAction:"...", visual:{type:'PEBBLE', color:0xA0522D, roughness:0.4, metalness:0, transparent:false} },
  { name:"天河石", theme:"鬆開緊抓的手", message:"...", question:"...", action:"...", subAction:"...", visual:{type:'MASSIVE', color:0x40E0D0, roughness:0.55, metalness:0, transparent:false } },
  { name:"紫水晶", theme:"信任你的直覺", message:"...", question:"...", action:"...", subAction:"...", visual:{type:'CLUSTER', color:0x9932CC, roughness:0.18, metalness:0.05, transparent:true, transmission:0.6 } },
  // ... 把剩餘 49 筆完整放回來
];

// ---------- THREE.js 基本場景 ----------
const container = document.getElementById('canvas-wrapper');
const scene = new THREE.Scene();

// camera
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 0, 30);

// renderer（改用 alpha: true 並保留先進設定）
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.physicallyCorrectLights = true;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
container.appendChild(renderer.domElement);

// Lights: Hemisphere + Directional + Rim (spot)
const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.45);
scene.add(hemi);

const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(8,10,8);
key.castShadow = false;
scene.add(key);

const rim = new THREE.SpotLight(0xD4AF37, 2.5, 100, Math.PI/6, 0.5);
rim.position.set(-10, 8, -6);
scene.add(rim);

// Simple procedural envMap (cube) — lightweight substitute for HDR
const cubeUrls = [
  // 6 tiny solid-color data URLs could be used; to keep file small we'll create a small cube texture procedurally
];
const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

// create a neutral environment by rendering a simple reflective sphere to a renderTarget? (Simpler approach: use Hemisphere as env influence)
scene.environment = null; // keep null if you don't have an HDR; hemisphere + lights will provide balanced lighting

// OrbitControls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.enablePan = false;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.3;
controls.enableZoom = true;

// Simple performance guard: reduce autoRotate when interacting
let userInteracting = false;
renderer.domElement.addEventListener('pointerdown', ()=>{ userInteracting = true; controls.autoRotate = false; });
window.addEventListener('pointerup', ()=>{ userInteracting = false; controls.autoRotate = true; });

// ---------- Nebula / particles (保留你原本概念，但更輕量) ----------
let nebulaGroup = new THREE.Group(); scene.add(nebulaGroup);
const simplex = new SimplexNoise();
let particles = [];

function initNebula(){
  // clear
  while(nebulaGroup.children.length) nebulaGroup.remove(nebulaGroup.children[0]);
  particles = [];
  crystalsData.forEach((d,i)=>{
    const geo = new THREE.IcosahedronGeometry(0.25 + Math.random()*0.3, 0);
    const mat = new THREE.MeshStandardMaterial({ color:d.visual.color, roughness:0.7, metalness:0.0 });
    const m = new THREE.Mesh(geo, mat);
    const angle = i * 0.35;
    const dist = 3 + i*0.22;
    m.position.set(Math.cos(angle)*dist, (Math.random()-0.5)*dist*0.3, Math.sin(angle)*dist);
    m.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
    nebulaGroup.add(m);
    particles.push({ mesh:m });
  });
  nebulaGroup.rotation.x = 0.2; scene.add(nebulaGroup);
}
initNebula();

// ---------- Crystal generator（改良材質以呈現礦物感） ----------
function createCrystalMesh(data){
  const group = new THREE.Group();
  const v = data.visual;

  // 建立更自然的 MeshPhysicalMaterial
  const matParams = {
    color: v.color || 0xffffff,
    metalness: v.metalness || 0,
    roughness: v.roughness !== undefined ? v.roughness : 0.3,
    transmission: v.transparent ? (v.transmission || 0.6) : 0.0,
    thickness: v.transparent ? (v.thickness || 1.5) : 0.0,
    side: THREE.DoubleSide,
    clearcoat: (v.roughness !== undefined && v.roughness < 0.4) ? 1.0 : 0.0,
    clearcoatRoughness: 0.05,
    reflectivity: 0.6
  };

  const material = new THREE.MeshPhysicalMaterial(matParams);

  // 依 visual.type 決定形狀：保留多樣化策略（POINT, CLUSTER, MASSIVE, PEBBLE, CUBIC, BLADE）
  const r = ()=> (Math.random()-0.5)*2;
  if (v.type === 'POINT'){
    const geo = new THREE.CylinderGeometry(0.15, 0.9, 6 + Math.random()*2, 7, 4);
    // apply vertex noise for natural look
    const pos = geo.attributes.position;
    const vec = new THREE.Vector3();
    for(let i=0;i<pos.count;i++){
      vec.fromBufferAttribute(pos,i);
      const n = simplex.noise3D(vec.x*0.45, vec.y*0.2, vec.z*0.45);
      vec.x += n*0.15; vec.z += n*0.15;
      pos.setXYZ(i, vec.x, vec.y, vec.z);
    }
    geo.computeVertexNormals();
    const mesh = new THREE.Mesh(geo, material); mesh.castShadow=true; group.add(mesh);
  } else if (v.type === 'CLUSTER'){
    // create several small prismatic shards
    const shards = 6 + Math.floor(Math.random()*6);
    for(let i=0;i<shards;i++){
      const h = 2 + Math.random()*4;
      const rad = 0.15 + Math.random()*0.5;
      const geo = new THREE.CylinderGeometry(0, rad, h, 5);
      const m = new THREE.Mesh(geo, material);
      m.position.set(r()*0.8, h/2 - 1 + r()*0.4, r()*0.8);
      m.rotation.set(Math.random()*1.6, Math.random()*Math.PI, Math.random()*1.6);
      group.add(m);
    }
  } else if (v.type === 'MASSIVE'){
    const geo = new THREE.IcosahedronGeometry(2.0, 3);
    const pos = geo.attributes.position;
    const vec = new THREE.Vector3();
    for(let i=0;i<pos.count;i++){
      vec.fromBufferAttribute(pos,i);
      const n = simplex.noise3D(vec.x*0.35, vec.y*0.35, vec.z*0.35);
      vec.multiplyScalar(1 + n*0.35);
      pos.setXYZ(i, vec.x, vec.y, vec.z);
    }
    geo.computeVertexNormals();
    const m = new THREE.Mesh(geo, material); group.add(m);
  } else if (v.type === 'CUBIC'){
    for(let i=0;i<3;i++){
      const s = 1.2 + Math.random()*1.6;
      const geo = new THREE.BoxGeometry(s,s,s);
      const m = new THREE.Mesh(geo, material);
      m.rotation.set(Math.random()*0.6, Math.random()*Math.PI, Math.random()*0.6);
      m.position.set(r()*0.6, r()*0.6, r()*0.6);
      group.add(m);
    }
  } else if (v.type === 'BLADE'){
    for(let i=0;i<10;i++){
      const w = 0.12 + Math.random()*0.3;
      const h = 3 + Math.random()*2.2;
      const d = 0.04 + Math.random()*0.08;
      const geo = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.Mesh(geo, material);
      m.position.set(r(), r()*0.5, r());
      m.rotation.set(r()*0.4, Math.random()*Math.PI, r()*0.6);
      group.add(m);
    }
  } else { // PEBBLE
    const geo = new THREE.IcosahedronGeometry(1.8, 2);
    const pos = geo.attributes.position;
    const vec = new THREE.Vector3();
    for(let i=0;i<pos.count;i++){ vec.fromBufferAttribute(pos,i); vec.multiplyScalar(1 + simplex.noise3D(vec.x*0.5, vec.y*0.5, vec.z*0.5)*0.18); pos.setXYZ(i,vec.x,vec.y,vec.z); }
    geo.computeVertexNormals();
    const mesh = new THREE.Mesh(geo, material); group.add(mesh);
  }

  // subtle float animation anchor
  group.userData.floatOffset = Math.random()*1000;
  return group;
}

// ---------- Interaction logic ----------
let mainCrystal = null;
let isResultMode = false;

function startJourney(){
  // fade landing
  document.getElementById('landing-content').style.opacity = 0;
  setTimeout(()=>{ document.getElementById('landing-content').style.display='none'; }, 600);

  // pick random crystal
  const crystal = crystalsData[Math.floor(Math.random()*crystalsData.length)];

  // explode nebula outward (visual)
  particles.forEach(p=>{ const dir = p.mesh.position.clone().normalize(); p.mesh.position.add(dir.multiplyScalar(60)); });

  setTimeout(()=>{
    scene.remove(nebulaGroup);
    showResult(crystal);
  }, 600);
}

function showResult(data){
  isResultMode = true; document.body.classList.add('result-mode');

  mainCrystal = createCrystalMesh(data);
  // position for layout harmony
  mainCrystal.position.set(window.innerWidth > 768 ? -2.5 : 0, window.innerWidth > 768 ? 0 : 1, 0);
  scene.add(mainCrystal);

  // set controls target to the crystal's center
  controls.target.copy(mainCrystal.position);
  camera.position.set(mainCrystal.position.x, mainCrystal.position.y, 14);
  controls.update();

  // show panel content
  const panel = document.getElementById('panel-content');
  panel.innerHTML = `
    <div style="text-align:center;margin-bottom:24px">
      <div style="font-family:Allura;font-size:2rem;color:${'#' + ( (data.visual && data.visual.color) ? (data.visual.color.toString(16).padStart(6,'0')) : 'ffffff' )}">${data.theme}</div>
      <div style="font-size:2.6rem;font-weight:600;color:#111">${data.name}</div>
    </div>
    <div style="margin-bottom:20px"><strong>Crystal Message</strong><div style="margin-top:8px">${data.message}</div></div>
    <div style="margin-top:20px"><strong>Core Question</strong><div style="margin-top:8px;color:#222">${data.question || ''}</div></div>
  `;
}

function resetApp(){
  document.body.classList.remove('result-mode');
  const landing = document.getElementById('landing-content'); landing.style.display='block'; setTimeout(()=>landing.style.opacity=1,80);
  if(mainCrystal){ scene.remove(mainCrystal); mainCrystal=null; }
  // re-init nebula
  initNebula();
  camera.position.set(0,0,30); controls.target.set(0,0,0); controls.update();
  isResultMode=false;
}

// ---------- animate ----------
function animate(){
  requestAnimationFrame(animate);
  if(!isResultMode){
    nebulaGroup.rotation.y += 0.0025;
    particles.forEach(p=>{ p.mesh.rotation.x += 0.015; p.mesh.rotation.y += 0.02; });
  } else {
    if(mainCrystal){
      mainCrystal.rotation.y += 0.003;
      mainCrystal.position.y += Math.sin((Date.now() + (mainCrystal.userData.floatOffset||0))*0.001) * 0.004;
    }
  }
  controls.update();
  renderer.render(scene, camera);
}
animate();

// ---------- resize ----------
window.addEventListener('resize', ()=>{
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h; camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});

// ---------- audio toggle (placeholder) ----------
const audio = new Audio(); // empty — you can set src
function toggleMusic(){
  if(!audio.src){ alert('請在程式中填入音樂檔案路徑'); return; }
  if(audio.paused){ audio.play(); document.getElementById('music-control').style.color = '#D4AF37'; }
  else{ audio.pause(); document.getElementById('music-control').style.color = 'rgba(255,255,255,0.7)'; }
}
</script>
</body>
</html>
